#pragma kernel LevelToField

struct Node
{
    float2 center;
    float radius;
    float4 color;
};


RWTexture2D<float4> Result;
StructuredBuffer<Node> Nodes;
StructuredBuffer<float4> Links;


//Mesh informations
float3 CornerLD;
float3 CornerRD;
float3 CornerRU;
float3 CornerLU;

//Player informations
float4 PlayerPosition;
float4 PlayerColor;

//Parameters
float BlendingFactor;
float LinkSize;
float CutThreshold;
float4 NormalRemap;


float CircleDistance(float2 center, float radius, float2 sample)
{
    return distance(center, sample) - radius;
}

float sminPolynomial(float a, float b, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

float sminPower(float a, float b, float k)
{
    a = pow(a, k);
    b = pow(b, k);
    return pow((a * b) / (a + b), 1.0 / k);
}

float smin(float a, float b, float k)
{
    float res = exp(-k * a) + exp(-k * b);
    return -log(res) / k;
}

[numthreads(32,32,1)]
void LevelToField(uint3 id : SV_DispatchThreadID)
{
    //Init variables
    uint count, strides;
    uint nCount, nStrides;
    uint lCount, lStrides;
    Result.GetDimensions(count, strides);
    Nodes.GetDimensions(nCount, nStrides);
    Links.GetDimensions(lCount, lStrides);
    float2 uv = id.xy / (float2)count;
    float2 worldPos = lerp(lerp(CornerLD, CornerRD, uv.x), lerp(CornerLU, CornerRU, uv.x), uv.y).xy;
    float4 color = float4(0,0,0,0);

    //Aggregate nodes
    float aggregate = 1;
    for (uint a = 0; a < nCount; ++a)
    {
        float dist = CircleDistance(Nodes[a].center, Nodes[a].radius, worldPos);
        color += saturate(1-dist) * Nodes[a].color;
        aggregate = sminPolynomial(aggregate, dist, BlendingFactor);
    }

    //Aggregate links
    for (uint b = 0; b < lCount; ++b)
    {
        float len = distance(Links[b].xy, Links[b].zw);
        float invLen = 1.0 / len;
        for (float j = 0; j < len; j += 0.5)
        {
            float t = j * invLen;
            float dist = CircleDistance(lerp(Links[b].xy, Links[b].zw, t), LinkSize, worldPos);
            dist *= dist;
            aggregate = sminPolynomial(aggregate, dist, BlendingFactor);
        }
    }

    //Aggregate player
    float dist = CircleDistance(PlayerPosition.xy, PlayerPosition.w, worldPos);
    color += saturate(1 - dist) * PlayerColor;
    aggregate = sminPolynomial(aggregate, dist, BlendingFactor);

    Result[id.xy] = float4(color.rgb, (aggregate - 1) * -NormalRemap.w);
}




#pragma kernel FieldToNormal
Texture2D<float4> SourceField;
RWTexture2D<float4> Normal;

[numthreads(32, 32, 1)]
void FieldToNormal(uint3 id : SV_DispatchThreadID)
{
    float factor = smoothstep(NormalRemap.x, NormalRemap.y, SourceField[id.xy].a);
    float cut = step(CutThreshold, SourceField[id.xy].a);

    float height = factor;
    float right = smoothstep(NormalRemap.x, NormalRemap.y, SourceField[int2(id.x + 1, id.y)].a);
    float up = smoothstep(NormalRemap.x, NormalRemap.y, SourceField[int2(id.x, id.y + 1)].a);
    float depth = 1;

    float normX = (height - right) * NormalRemap.z + .5;
    float normY = (height - up) * NormalRemap.z + .5;

    float3 normal = normalize(float3(normX, normY, depth));
    Normal[id.xy] = float4(normal, cut);

}
